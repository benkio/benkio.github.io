<!doctype html>
<html lang="en">
<head>
<title>Gilded Rose Kata</title>
<!-- 2025-05-16 Fri 20:19 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="generator" content="Org-mode">
<meta name="author" content="Enrico Benini">

<link  href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.5/css/bootstrap.min.css" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.5/js/bootstrap.min.js"></script>
<style>body { margin-bottom: 0px; }</style><script>
$(function() {
    'use strict';

    $('.bs-docs-sidebar li').first().addClass('active');

    $(document.body).scrollspy({target: '.bs-docs-sidebar'});

    $('.bs-docs-sidebar').affix();
});
</script><link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon">
<link rel="icon" href="../images/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/css/all.min.css">
<link href="https://fonts.googleapis.com/css?family=Montserrat" rel="stylesheet" type="text/css">
<link href="https://fonts.googleapis.com/css?family=Lato" rel="stylesheet" type="text/css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
<link rel="stylesheet" href="../css/main.css">
<link rel="stylesheet" href="../css/blog.css">
<link rel="stylesheet" href="../css/article.css">
</head>
<body>
<div id="content" class="container">
<div class="row"><div class="col-md-3 col-md-push-9"><nav id="table-of-contents">
<div id="text-table-of-contents" class="bs-docs-sidebar">
<ul class="nav">
<li><a href="#navbar">Blog</a></li>
<li><a href="#Article">Gilded Rose Kata</a>
<ul class="nav">
<li><a href="#ArticleAbstract">Abstract</a></li>
<li><a href="#ArticleContent">Content</a>
<ul class="nav">
<li><a href="#CodebaseStateContent">Codebase State</a></li>
<li><a href="#SolutionApproachContent">Solution Approach</a>
<ul class="nav">
<li><a href="#SolutionApproachTestsContent">Tests</a></li>
<li><a href="#SolutionApproachSplitMonsterContent">Split the Monster</a></li>
<li><a href="#SolutionApproachMutationContent">Dealing With Mutation once and for All</a></li>
<li><a href="#SolutionApproachRefinementNewFeatureContent">Refinement &amp; New feature</a></li>
</ul>
</li>
<li><a href="#ScalaContent">Scala Kata</a></li>
<li><a href="#HaskellContent">Haskell Kata</a></li>
</ul>
</li>
<li><a href="#ArticleConclusions">Conclusions</a>
<ul class="nav">
<li><a href="#MainChallengesConclusion">Main Challenges</a></li>
<li><a href="#LaguagesComparisonConclusions">Languages Comparison</a></li>
<li><a href="#LaguagesComparisonConclusions">Final words</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#ShareButtons">Share Buttons</a></li>
</ul>
</div>
</nav>
</div><div class="col-md-9 col-md-pull-3"><h1 class="title">Gilded Rose Kata</h1>
<div id="outline-container-navbar" class="outline-2 text-center navbar navbar-inverse navbar-fixed-top">
<h2 id="navbar"><a id="sec-" name="sec-"></a>Blog</h2>
<div class="outline-text-2" id="text-navbar">
<button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#collapsableNavbar">
  <span class="icon-bar"></span>
  <span class="icon-bar"></span>
  <span class="icon-bar"></span>
</button>
<a title="Home" href="../blog.html"><h1 id="navbarTitle" class="navbar-text">Blog</h1></a>
<div class="collapse navbar-collapse" id="collapsableNavbar">
  <ul class="nav navbar-nav">
    <li><a title="Home" href="../index.html"><i class="fas fa-home fa-3x" aria-hidden="true"></i></a></li>
    <li><a title="Article List" href="../articleList.html" class="navbar-text h3">Article List</a></li>
<li><a title="Book List" href="../bookList.html" class="navbar-text h3">Book List</a></li>
    <li><a title="Album List" href="../albumList.html" class="navbar-text h3">Album List</a></li>
    <li><a title="Note Trainer" href="../NoteTrainer/NoteTrainer.html" class="navbar-text h3">Note Trainer</a></li>
  </ul>
</div>
</div>
</div>
<div id="outline-container-Article" class="outline-2">
<h2 id="Article"><a id="sec-" name="sec-"></a>Gilded Rose Kata</h2>
<div class="outline-text-2" id="text-Article">
<p>
<b>Created: <span class="timestamp-wrapper"><span class="timestamp">&lt;2020-06-30 Tue&gt;</span></span></b>
</p>
</div>
<div id="outline-container-ArticleAbstract" class="outline-3">
<h3 id="ArticleAbstract"><a id="sec-" name="sec-"></a>Abstract</h3>
<div class="outline-text-3" id="text-ArticleAbstract">
<p>
Not so long ago. I watched the mighty <a href="https://twitter.com/NicolasRinaudo">Nicolas Rinaudo</a> dealing with
the <a href="https://github.com/emilybache/GildedRose-Refactoring-Kata">Gilded Rose Kata</a> on the <a href="https://www.twitch.tv/scalalove">Scalalove's twitch channel</a>, and that
inspired me into trying it out using my favorite languages: Scala &amp;
Haskell.
</p>

<p>
I'll structure the article in this way:
</p>
<ol class="org-ol">
<li>I get familiar with the actual code-base, analyze it, and
explain what are the (main) flaws I can see.
</li>
<li>Following the previous point, I write down the approach I'll
use.
</li>
<li>Execution time with a brief log journal of what was done.
</li>
<li>Then, It's time to point out the difficulties I have found with
both Scala and Haskell and I will try to do a comparison between the
two.
</li>
</ol>

<p>
Both points 1 and 2 will be language-independent
</p>
</div>
</div>
<div id="outline-container-ArticleContent" class="outline-3">
<h3 id="ArticleContent"><a id="sec-" name="sec-"></a>Content</h3>
<div class="outline-text-3" id="text-ArticleContent">
</div>
<div id="outline-container-CodebaseStateContent" class="outline-4">
<h4 id="CodebaseStateContent"><a id="sec-" name="sec-"></a>Codebase State</h4>
<div class="outline-text-4" id="text-CodebaseStateContent">
<p>
In order to write this section, I just need to access the <a href="https://github.com/emilybache/GildedRose-Refactoring-Kata">Github kata
repo</a> and do a good, old, code review. I will take Scala as a
reference since I feel more comfortable with the technology.
</p>

<p>
<b>Disclaimer:</b> this code is intentionally bad. If you will ever
encounter a code-base like this one in your life, listen to me&#x2026;
</p>

<div class="video-container"><iframe src="https://giphy.com/embed/A6PcmRqkyMOBy" frameBorder="0" class="giphy-embed responsive-iframe" allowFullScreen></iframe></div>

<p>
let's start&#x2026;
</p>

<p>
First thing first, I see there are no tests. That needs to be
fixed ASAP. We will talk about that in the <a href="#SolutionApproachTestsContent">specific section</a>.
</p>

<p>
Then, I see an attempt of a <i><a href="https://en.wikipedia.org/wiki/Domain_model">Domain Model</a></i>. That's actually a good
practice: design your types first and be as picky as possible in
order to <a href="https://fsharpforfunandprofit.com/posts/designing-with-types-making-illegal-states-unrepresentable/">make the illegal states unrepresentable</a>. 
</p>

<p>
Moving on to The problems I found doing the code review:
are several
</p>
<ul class="org-ul">
<li>The <code>var</code> keyword, that means mutability. As a software engineer, I
know that mutable state can be hard to manage and lead to unintended
behaviours. Doing a quick sneak peek to the Haskell code I see
there's none. Mutation is possible in Haskell too, but luckily we got
spared this time. I will talk a little bit more about mutation
in the <a href="#LaguagesComparisonConclusions">Languages Comparison Section</a>.
</li>
<li>Just Item Type!! There are two possible cases for this: the problem is
extremely simple or we are missing some types here.
</li>
<li>No validations. I expect to see some data validation hiding
somewhere in the algorithm. Basically every piece of code has it
because we need to ensure that the values we are going to manage
remains valid throughout the program execution.
</li>
</ul>

<p>
Regarding the main algorithm, we have:
</p>
<ol class="org-ol">
<li>One giant function. OK, that is, in the end, what the CPU will
execute: 1 operation at a time(mono-core,
single-thread). However, the code needs to be
human-readable. <i>Any fool can write code that a computer can understand. Good programmers write code that humans can understand.</i> (Martin Fowler) Plus, it violates the <a href="https://en.wikipedia.org/wiki/Single-responsibility_principle">Single
Responsibility Principle</a>.
</li>
<li>Mutation again! Apart from the items fields, that was expected,
there's mutation regarding the index variable <code>i</code>. Luckily, it is just
used to select the current element to evaluate, it could have
been way worse, like a different algorithm for odd and even
elements, checks on the index, and so on. 😖
</li>
<li>There should be Types and a compiler somewhere, but I don't see
any usage of those in here. The code is nearly indistinguishable
from Javascript.
</li>
<li>Nested Ifs statements. No need to tell you why it is bad.
</li>
</ol>
</div>
</div>
<div id="outline-container-SolutionApproachContent" class="outline-4">
<h4 id="SolutionApproachContent"><a id="sec-" name="sec-"></a>Solution Approach</h4>
<div class="outline-text-4" id="text-SolutionApproachContent">
<p>
After the code review we know the issues of the code and we can
come up with a plan. Here, I'll prioritise the tasks we need to do
in order to make this code better and solve the Kata.
</p>
</div>
<div id="outline-container-SolutionApproachTestsContent" class="outline-5">
<h5 id="SolutionApproachTestsContent"><a id="sec-" name="sec-"></a>Tests</h5>
<div class="outline-text-5" id="text-SolutionApproachTestsContent">
<p>
The first thing needed is a good test suite. With proper testing,
we will be sure that the changes we are going to make are
correct, Meaning that the behavior of the program is
preserved. After all, the definition of <i><a href="https://en.wikipedia.org/wiki/Code_refactoring">Code Refactoring</a></i> is to
<b>NOT</b> change the program behavior.
</p>

<p>
Now, the test suite can be crafted using multiple techniques and it's a
huge topic by itself. In this case, testing is not the main focus of
the kata but is still a key point. Fortunately, it's a simple, little, local
program. So we should be fine with just <i><a href="https://en.wikipedia.org/wiki/Unit_testing">Unit Testing</a></i> and <i><a href="https://en.wikipedia.org/wiki/System_testing">System Testing</a></i>.
</p>

<p>
Usually, testing is done by:
</p>
<ul class="org-ul">
<li>Providing some specific input data to the program.
</li>
<li>Fetch the result of the computation.
</li>
<li>Compare it with what is expected.
</li>
</ul>

<p>
That's completely fine and it's what the majority of the
companies do nowadays. The downside of this approach is: it's
static. Let say your program has a bug and will crash under
specific conditions, for a corner case you didn't think about.
Testing by example will not help you there, if you didn't catch
that specific case beforehand.
</p>

<p>
A different approach I like more is <a href="https://en.wikipedia.org/wiki/Property_testing">Property Testing</a>, where the
input data is <b>generated</b>. The software engineer defines the
input generation rules, used by the supporting library/framework,
and then the expected behavior as a property. I won't go deeper
into it, but the typical example is the <i>associativity law</i> of
the sum. Definitely, the most complicated part is to identify the
properties of your program, but in my honest opinion, I still see
benefits in just take advantage of the generated inputs and
having a "normal" test built on top. Having to write your test
once and run them multiple times with several inputs, it's
straight away a big plus. Used this way, we probably can't talk
about <i>Property</i> testing anymore, but I can't think of a proper
term, if you know it, please tell me.
</p>

<p>
The biggest downside of this approach is the computational cost:
generating inputs and having multiple runs will increase the
testing time. In fact, if you mess up the way you generate your
input, you couldn't even be able to run your test at all,
obtaining the "infinite loop effect" at the time of
execution. For example, I learnt by experience that, operators
like <code>suchAs</code> must be used very carefully.
</p>

<p>
<b><b>Edit:</b></b> Since we have even the specs of the program the
property base testing fits super nicely: convert phrases like
</p>

<p>
<i>“Sulfuras”, being a legendary item, never has to be sold or
decreases in Quality</i>
</p>

<p>
to a property becomes quite a natural process.
</p>
</div>
</div>
<div id="outline-container-SolutionApproachSplitMonsterContent" class="outline-5">
<h5 id="SolutionApproachSplitMonsterContent"><a id="sec-" name="sec-"></a>Split the Monster</h5>
<div class="outline-text-5" id="text-SolutionApproachSplitMonsterContent">
<p>
Once we have the testing set up properly, we can start to break
stuff using the 🔨.
</p>

<p>
The Most annoying thing in the codebase is the giant stand-alone
function. I will tackle this by splitting that function into
sub-functions. Then, repeat the same approach for the outcoming
functions. This recursive process will terminate when the
functions I end up with have a small number of lines of code,
one single mutation in it or just one if statement. Simple as that.
</p>

<p>
A little but key detail in all of this is that each function will
return a value, and the parent function will be a composition of
its child.
</p>

<p>
This works well when you have 2 consecutive if-statements or an
if-else-statement:
</p>

<div class="org-src-container">

<pre class="src src-scala"><span style="color: #ff7f24;">// Before</span>
<span style="color: #00ffff;">if</span> (<span style="color: #eedd82;">condition1</span>) {
  <span style="color: #00ffff;">if</span> (<span style="color: #eedd82;">condition2</span>) {
   <span style="color: #ff7f24;">// Stuff</span>
  } <span style="color: #00ffff;">else</span> <span style="color: #ff7f24;">// Stuff</span>
}
<span style="color: #00ffff;">if</span> (<span style="color: #eedd82;">condition3</span>) {
<span style="color: #ff7f24;">// Stuff</span>
} <span style="color: #00ffff;">else</span> <span style="color: #ff7f24;">// Stuff</span>

<span style="color: #ff7f24;">// After</span>
<span style="color: #eedd82;">def</span> <span style="color: #eedd82;">f1</span>(<span style="color: #eedd82;">params</span>): <span style="color: #98fb98;">StuffType</span> = <span style="color: #98fb98;">if</span> (<span style="color: #98fb98;">condition1</span>) { <span style="color: #87cefa;">f2</span>(<span style="color: #eedd82;">params</span>) } <span style="color: #eedd82;">else</span> <span style="color: #ff7f24;">// Previous state (identity)</span>
<span style="color: #98fb98;">def</span> <span style="color: #eedd82;">f2</span>(<span style="color: #98fb98;">params</span>): <span style="color: #eedd82;">StuffType</span> <span style="color: #98fb98;">=</span> <span style="color: #00ffff;">if</span> (<span style="color: #eedd82;">condition2</span>) {<span style="color: #ff7f24;">/* Stuff */</span> } <span style="color: #00ffff;">else</span> <span style="color: #ff7f24;">// Stuff</span>
<span style="color: #eedd82;">def</span> <span style="color: #eedd82;">f3</span>(<span style="color: #eedd82;">params</span>): <span style="color: #98fb98;">StuffType</span> = <span style="color: #98fb98;">if</span> (<span style="color: #98fb98;">condition3</span>) {<span style="color: #ff7f24;">/* Stuff */</span> } <span style="color: #eedd82;">else</span> <span style="color: #ff7f24;">// Stuff</span>
<span style="color: #98fb98;">val</span> <span style="color: #eedd82;">r1</span> <span style="color: #98fb98;">=</span> <span style="color: #eedd82;">f1</span>(<span style="color: #98fb98;">args</span>)
<span style="color: #00ffff;">val</span> <span style="color: #eedd82;">r2</span> = <span style="color: #87cefa;">f3</span>(<span style="color: #eedd82;">args</span>) <span style="color: #ff7f24;">// This might probably require r1 as input</span>
<span style="color: #eedd82;">r2</span>
</pre>
</div>

<p>
This might seems controversial and more complicated, but it helps
to put the computations in context. This way, you don't need to
go and look into the content of the functions, you can just skip
their implementation details and get an overall feeling of the
data-flow. Just imagine if the <code>Stuff</code> size is hundred of lines,
but you are interested only in <code>f3</code>. After this refactoring, you can
just search for <code>f3</code>, go to his definition, and forget about the
rest. Plus, by doing so, we can move the functions away, to a
different file for instance.
</p>

<p>
You might also notice I added an else to the first if that wasn't
there. That's because I want the wrapping function to actually
return a type and, since there wasn't an else in that case, the
result will be the previous input. When the else branch is chosen
the <code>f1</code> function will behave as the <a href="https://en.wikipedia.org/wiki/Identity_function">Identity Function</a>. With this
trick, we are finally able to put types back into play!
</p>

<p>
In the very end, I want also to grab your attention on the way
this approach penetrates the nested ifs and allows us to collapse the
structure. Of course, we could also merge <code>condition1</code> and
<code>condition2</code>, and we might actually decide to do that in a later
stage, but let us suppose we will discover that the same logic of
<code>f2</code> is reused. This way, we can just call <code>f2</code> since it's
independent from the rest.
</p>

<p>
<b>Edit:</b> a very important aspect when comes to refactoring is <b>KNOW WHEN TO COMMIT</b>. 
In my opinion, the right time is when all of the
following conditions hold:
</p>
<ol class="org-ol">
<li>Your tests are green
</li>
<li>You are not in the middle of a change (you know what to do
next)
</li>
<li>You are on stand-by, thinking about the next move (related to
point 2)
</li>
</ol>

<p>
Doing like that, will ensure that you commit quite often and you
can roll back to a <i>safe-state</i> without loosing too much
time. Otherwise, you might don't want to roll back because your
last commit was 2h ago, but you can't carry on because you are
stuck for some reason.
</p>

<p>
<b>Edit:</b> Since this specific problem is mainly just nested if, at
some point, we actually want to merge them together and collapse
some of the independent functions into one. You might think that
we will roll back to the start, but we can instead take
advantage of specific language constructs, like pattern matching,
to keep the structure flat.
</p>
</div>
</div>
<div id="outline-container-SolutionApproachMutationContent" class="outline-5">
<h5 id="SolutionApproachMutationContent"><a id="sec-" name="sec-"></a>Dealing With Mutation once and for All</h5>
<div class="outline-text-5" id="text-SolutionApproachMutationContent">
<p>
Everything is in its own box, each one returning a value 💜,
However&#x2026; it still mutates and internal field!! 😞
</p>

<p>
Anyway, due to the previous steps, we can easily remove that
mutation from the algorithm and the model itself, returning a new
copy of the input with the requested changes.
</p>

<p>
<b><b>Edit:</b></b> Reading the specification I found I'm not allowed to
  touch the <code>Item</code> class, unfortunately. Then, what we can do is
  to add other types around the main one, those will helps us to
  structure our code and give to each bit of logic its own
  context. A good Idea could be to add an internal representation
  of the <code>Item</code>, not visible from outside. Doing so will add the
  conversion overhead from <code>Item</code> to the internal type, but we
  are the owner of it, so it can change and be
  immutable. Basically, we are going to decouple ourselves from
  the foreign <code>Item</code> type.
</p>
</div>
</div>
<div id="outline-container-SolutionApproachRefinementNewFeatureContent" class="outline-5">
<h5 id="SolutionApproachRefinementNewFeatureContent"><a id="sec-" name="sec-"></a>Refinement &amp; New feature</h5>
<div class="outline-text-5" id="text-SolutionApproachRefinementNewFeatureContent">
<p>
Finally, with this new working codebase, we should be able to:
</p>
<ul class="org-ul">
<li>Merging conditions together.
</li>
<li>Adding fields validation or other helpful functions,
</li>
<li>Adding new types.
</li>
<li>Structuring the code: moving the functions to the model companion
objects, in case of Scala, or to a separate module.
</li>
</ul>

<p>
Once the code is finally in good shape, we can:
</p>
<ol class="org-ol">
<li>See some pattern emerge clearly and properly design the rest
of the code to expose them: moving the logic to proper new
types that communicate the intention of the code.
</li>
<li>easily add the new feature. It should be quite simple since
the new item to evaluate, require a logic that is already shared
with another item.
</li>
</ol>

<p>
Now that we have a plan, let's start the fun part&#x2026;let's
executed it!
</p>

<p>
<b><b>Edit:</b></b> Sometimes, you need to do some refinements listed here
in earlier stages. That's because, it helps you a lot rather
then postpone the change. Anyway, my suggestion is to refine as
little as possible in the beginning, only when it's really necessary.
</p>
</div>
</div>
</div>
<div id="outline-container-ScalaContent" class="outline-4">
<h4 id="ScalaContent"><a id="sec-" name="sec-"></a>Scala Kata</h4>
<div class="outline-text-4" id="text-ScalaContent">
<p>
<span class="timestamp-wrapper"><span class="timestamp">&lt;2020-07-02 Thu&gt;</span></span>: Started the scala exercise from testing and
<a href="https://www.scalacheck.org/">Scalacheck</a>. Get stuck on some test corner case, but with some
<code>println</code> I figured it out. <a href="https://github.com/benkio/GeneralExercises/commit/8e066e5cc678518f6f10147f7280969dce245be2">commit</a>
</p>

<p>
<span class="timestamp-wrapper"><span class="timestamp">&lt;2020-07-03 Fri&gt;</span></span>: Finished Scala's tests. Fixed some errors in
the making. Now we can move to the actual code. <a href="https://github.com/benkio/GeneralExercises/commit/19c8b9e">commit</a>
</p>

<p>
<span class="timestamp-wrapper"><span class="timestamp">&lt;2020-07-04 Sat&gt;</span></span>: Split the monster. Now, I have several
functions, returning Items containing only one if statement as
a body. No more two level if indentation anywhere. Plus:
</p>
<ul class="org-ul">
<li>Introduced new types wrapper and aliases for the fields
</li>
<li>Defer/remove mutation as much as possible. Only at the end of
the <code>foreach</code>.
</li>
<li>Extracted main operation on types to companion objects.
</li>
<li>Merged the functions into one calling only basic operations
</li>
</ul>
<p>
<a href="https://github.com/benkio/GeneralExercises/commit/9fdc7be">commit</a>
</p>

<p>
<span class="timestamp-wrapper"><span class="timestamp">&lt;2020-07-05 Sun&gt;</span></span>: Changed the return type of the <code>updateQuality</code>
to be the new value. In this way, we avoid mutation of the item
array. After that, we can see the pattern composed by a
pre-quality calculation, an increase in sellIn value, a final
adjustment. Then, we can create subtypes of the item class and put
the specific logic into each class. This way we can get rid of the
big remaining functions. Afterward, we can add the new class for
the new item easily. Work is done! <a href="https://github.com/benkio/GeneralExercises/commit/03ac121">commit</a>
</p>
</div>
</div>
<div id="outline-container-HaskellContent" class="outline-4">
<h4 id="HaskellContent"><a id="sec-" name="sec-"></a>Haskell Kata</h4>
<div class="outline-text-4" id="text-HaskellContent">
<p>
<span class="timestamp-wrapper"><span class="timestamp">&lt;2020-07-08 Wed&gt;</span></span>: Started the tests: Sulfuras + AgedBrie. <a href="https://github.com/benkio/GeneralExercises/commit/ea0b859">commit</a>
</p>

<p>
<span class="timestamp-wrapper"><span class="timestamp">&lt;2020-07-13 Mon&gt;</span></span>: Added the BackstagePasses test + test
refactoring <a href="https://github.com/benkio/GeneralExercises/commit/8a9a98b">commit</a>
</p>

<p>
<span class="timestamp-wrapper"><span class="timestamp">&lt;2020-07-14 Tue&gt;</span></span>: Tests completed. <a href="https://github.com/benkio/GeneralExercises/commit/f19fa11">commit</a>
</p>

<p>
<span class="timestamp-wrapper"><span class="timestamp">&lt;2020-07-15 Wed&gt;</span></span>: Started to split the monster. Added
Hlint, you can't imagine how many <i>redundant brackets</i> I removed. <a href="https://github.com/benkio/GeneralExercises/commit/acce770">commit</a>
</p>

<p>
<span class="timestamp-wrapper"><span class="timestamp">&lt;2020-07-16 Thu&gt;</span></span>: Add a <code>newtype</code> for the quality field, add the
special item type, setup the <code>HasQuality</code> typeclass, merged if
functions together into a guard function. <a href="https://github.com/benkio/GeneralExercises/commit/89db36e">commit</a>
</p>

<p>
<span class="timestamp-wrapper"><span class="timestamp">&lt;2020-07-16 Thu&gt;</span></span>:
</p>
<ul class="org-ul">
<li>Implemented typeclass instances and used instead of plain
functions
</li>
<li>Moved all the logic about items in a separate file
</li>
<li>Finished the refactoring
</li>
<li>Added the new special item Conjured
</li>
<li>Added the new test
</li>
<li>Implemented the type class instances
</li>
</ul>
<p>
<b>KATA DONE</b> <a href="https://github.com/benkio/GeneralExercises/commit/9205f58">commit</a>
</p>
</div>
</div>
</div>
<div id="outline-container-ArticleConclusions" class="outline-3">
<h3 id="ArticleConclusions"><a id="sec-" name="sec-"></a>Conclusions</h3>
<div class="outline-text-3" id="text-ArticleConclusions">
</div>
<div id="outline-container-MainChallengesConclusion" class="outline-4">
<h4 id="MainChallengesConclusion"><a id="sec-" name="sec-"></a>Main Challenges</h4>
<div class="outline-text-4" id="text-MainChallengesConclusion">
<p>
The first challenge that comes into my mind is test
crafting. During this kata you really understand the importance of
having a very well done test code. Most of the time we think test
code is B-class code, but this kata shows it's not. It needs to be
very fine-tuned and precise in order to catch bugs ahead of
time. Plus, test-code is code you need to maintain and write
daily, to add your features. That makes it at the same level of
importance as the production code.
</p>

<p>
I agree, it's not great fun to write such code, that's why I
suggest to use the compiler as much as possible to reduce the
design space and the amount of tests you need to write to cover
your application. If a behavior is impossible, you don't need to
add a test for it.
</p>

<p>
A second relevant challenge is about being
disciplined. Refactoring should be a sequence of very small
changes, but this is not always possible. Sometimes, you need to
break quite some amount of code at once, but that must be an
exception to the regular refactoring process. Said from a guy who usually opens refactoring PRs of hundreds of files. 🙊 😬
</p>

<p>
What can happen is that we might see multiple applicable
improvements at the same time. Therefore, we are tempted to apply
them all at once, instead, we should hold back and do one single,
small, consistent change, commit it, and then move on to the
next. This requires great self-discipline.
</p>

<p>
Finally, the last challenge, is definitely <i>dependencies</i>. When
you have constraints from different libraries or legacy code that
you are not allowed to change, it makes things very difficult and
requires you to put workarounds in place. That defiles the goal of
refactoring itself. This shows the importance of keeping projects
small, self-contained and decoupled from each other as much as
possible, with the minimal set of dependencies as possible.
</p>
</div>
</div>
<div id="outline-container-LaguagesComparisonConclusions" class="outline-4">
<h4 id="LaguagesComparisonConclusions"><a id="sec-" name="sec-"></a>Languages Comparison</h4>
<div class="outline-text-4" id="text-LaguagesComparisonConclusions">
<p>
Before diving into the differences I found between the two
technologies, I feel the need to do a little disclaimer. What I
will write is a personal opinion, after all, it's not based on
facts, but on personal experience. Therefore, it depends on: my
emotions throughout the exercise, how fluent I am on both
languages, and how much I know about the problem (the order in
which I solved the Kata might have influenced me). Therefore,
what's following may not apply to you and you disagree, that's
completely fine.  Probably this disclaimer should have been placed
at the very start of this article 😺.
</p>

<p>
One of the first differences I felt, when dealing with tests in
Haskell, was that I was pushed way more into abstracting things
compared to Scala and I might figure out why.
</p>

<p>
In Scala, if a test fails, what I usually do to debug it is:
putting a break point or a <code>println</code> and see what is the input to
the test, the result an so on. Once I know what is going on, it's
usually an easy fix: the generator wasn't right, the success
condition wasn't correct etc&#x2026; and that's it.
</p>

<p>
This approach doesn't hold in Haskell because you can't put a
simple <code>println</code> into the tests. You know, <a href="https://www.youtube.com/watch?v=fCoQb-zqYDI">IO Monad</a> and
stuff. So, you need to work differently and, as a result, you end
up with better code. Let's see why.
</p>

<p>
The only way to inspect your test I know in Haskell is to use the
REPL. When you get into it, you want to be able to execute exactly
the bit of code you are interested in, the minimal amount of code
where the bug might hide. To achieve this goal, you need to
extract the logic of your tests into small functions and enhance
the re-usability as much as possible instead of just care about
fixing the single test.
</p>

<p>
This should always be the case, for whatever language you are
using, but I strongly believe that, if something is not forced by
the technology and the responsibility of "doing the right thing"
is on the shoulder of the developer, laziness and negligence will
eventually kick in and drive it to a sub-optimal result.
</p>

<p>
Moving on, the next difference, we can see from the initial
codebase status that Haskell comes with immutability straight
away. Even if it doesn't seem very important, this is a big plus,
especially when things scale up in size. Then, you could achieve
mutation in Haskell as well using specific constructions like <a href="https://www.oreilly.com/library/view/parallel-and-concurrent/9781449335939/ch07.html">MVar</a>
or <a href="https://wiki.haskell.org/Software_transactional_memory">STM</a> (used mainly for concurrency purposes), but even then,
mutation is enclosed and accessible under a specific contract
where particular constraints hold. Having immutability as a
default saves you time, since we can skip a step in our
refactoring plan.
</p>

<p>
Moreover, I found the starting impact of the refactoring less
scary than the Scala one. I guess the reason is because I
already know the context, but I was able to give a meaningful name
to the extracted functions straight away because of the usage of
the <code>where</code> and <code>let-in</code> constructs.
</p>

<hr/>

<p>
let me open a small parenthesis in here
</p>

<div class="org-src-container">

<pre class="src src-haskell">    src<span style="color: #eedd82;">/</span>GildedRose.hs<span style="color: #98fb98;">:</span>53<span style="color: #98fb98;">:</span>29<span style="color: #98fb98;">:</span> <span style="color: #98fb98;">Warning:</span> <span style="color: #98fb98;">Redundant</span> <span style="color: #00ffff;">if</span>
<span style="color: #98fb98;">Found</span><span style="color: #87cefa;">:</span>
  <span style="color: #00ffff;">if</span> sellIn <span style="color: #eedd82;">&lt;</span> 6 <span style="color: #00ffff;">then</span> <span style="color: #00ffff;">if</span> quality <span style="color: #eedd82;">&lt;</span> 48 <span style="color: #00ffff;">then</span> 1 <span style="color: #00ffff;">else</span> 0 <span style="color: #00ffff;">else</span> 0
<span style="color: #98fb98;">Perhaps</span><span style="color: #87cefa;">:</span>
  <span style="color: #00ffff;">if</span> (sellIn <span style="color: #eedd82;">&lt;</span> 6) <span style="color: #eedd82;">&amp;&amp;</span> (quality <span style="color: #eedd82;">&lt;</span> 48) <span style="color: #00ffff;">then</span> 1 <span style="color: #00ffff;">else</span> 0
</pre>
</div>

<p>
<b><a href="https://github.com/ndmitchell/hlint">Hlint</a> is cheating in this exercise</b> and it works only because
each redundant ifs has to return a value. Scala also has similar
tools, like <a href="https://github.com/scalacenter/scalafix">Scalafix</a>, but it slipped out of my mind. With it, I
would have struggled less.
</p>

<hr/>

<p>
Finally, a downside of plain Haskell, in comparison to Scala, is
the amount of machinery you have to create in order to do simple
things, such as just access fields. Don't get me wrong here, I'm
sure that through some specific compiler extension, or using
<a href="http://wiki.haskell.org/Template_Haskell">Template Haskell</a>, a cleaver/experienced haskeller can easily
overcome this limitation, auto-generating instances for
example. Anyway, I'm not a great Haskell developer and I just
wanted to compare the two languages out of the box, with minimal
overhead possible. A possible justification I can think of is that
Haskell prefers to keep a minimal core, and then it allow you to
integrate the language using external
modules/extensions/libraries. As a result, it's often told that
Commercial Haskell is far different from the plain language, due
to the high amount of pieces involved that completely turn
upside-down the syntax. As a reference to it I link a proper book
discussing <a href="https://github.com/sdiehl/wiwinwlh">What I Wish I Knew When Learning Haskell</a>. I hope to
find the time to read this one day.
</p>
</div>
</div>
<div id="outline-container-LaguagesComparisonConclusions" class="outline-4">
<h4 id="LaguagesComparisonConclusions"><a id="sec-" name="sec-"></a>Final words</h4>
<div class="outline-text-4" id="text-LaguagesComparisonConclusions">
<p>
To be completely honest, I must say that most of the concepts I
showed here are quite old and you can find them into details from
several famous books, such as <a href="https://martinfowler.com/books/refactoring.html">Refactoring by Martin Fowler</a>.
</p>

<p>
Anyway, you can see here the application of some of those
principles, plus what does in means to refactor in a FP oriented language.
</p>

<p>
I really hope you enjoyed reading this article and that it
inspired you into trying this kata, especially if you aren't
confident with Refactoring practices. Feel free to contact me if
you have any feedback.
</p>

<p>
May the force be with you
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-ShareButtons" class="outline-2">
<h2 id="ShareButtons"><a id="sec-" name="sec-"></a>Share Buttons</h2>
<div class="outline-text-2" id="text-ShareButtons">
<!-- AddToAny BEGIN -->
<hr>
<div class="a2a_kit a2a_kit_size_32 a2a_default_style">
<a class="a2a_dd" href="https://www.addtoany.com/share"></a>
<a class="a2a_button_facebook"></a>
<a class="a2a_button_twitter"></a>
<a class="a2a_button_whatsapp"></a>
<a class="a2a_button_telegram"></a>
<a class="a2a_button_linkedin"></a>
<a class="a2a_button_email"></a>
</div>
<script async src="https://static.addtoany.com/menu/page.js"></script>
<!-- AddToAny END -->

<script type="text/javascript">
$(function() {
  $('#text-table-of-contents > ul li').first().css("display", "none");
  $('#text-table-of-contents > ul li').last().css("display", "none");
  $('#table-of-contents').addClass("visible-lg")
});
</script>
<div id="disqus_thread"></div>
<script>
    /**
    *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
    *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables    */
    /*
    var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    */
    (function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = 'https://benkio-github-io.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
</div>
</div></div></div>
</body>
</html>
